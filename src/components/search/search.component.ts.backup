import { Component, EventEmitter, Output, ViewChild, ElementRef, AfterViewInit, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ApiService } from '../../services/api.service';
import { LocationService } from '../../services/location.service';
import { SearchRequest, UserPreferences } from '../../models/restaurant.model';

declare var google: any;

@Component({
  selector: 'app-search',
  standalone: true,
  imports: [CommonModule, FormsModule],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  templateUrl: './search.component.html',
  styleUrls: ['./search.component.css']
})
export class SearchComponent implements AfterViewInit {
  @Output() onSearch = new EventEmitter<SearchRequest>();
  @ViewChild('placePickerContainer') placePickerContainer!: ElementRef;

  address: string = '';
  loading: boolean = false;
  showDietaryDropdown: boolean = false;
  private selectedPlace: any = null;
  private placeAutocompleteElement: any = null;

  preferences: UserPreferences = {
    maxDistance: 10,
    minRating: 3.0,
    dietaryRestrictions: [],
    favoriteStyles: []
  };

  availableDietaryRestrictions = ['Vegetarian', 'Vegan', 'Gluten-Free', 'Dairy-Free'];

  get selectedDietaryCount(): number {
    return this.preferences.dietaryRestrictions.length;
  }

  constructor(
    private apiService: ApiService,
    private locationService: LocationService
  ) {}

  ngAfterViewInit() {
    // Wait for Google Maps to be ready
    this.waitForGoogleMaps();
  }

  waitForGoogleMaps() {
    if ((window as any).googleMapsLoaded && typeof google !== 'undefined' && google.maps && google.maps.places) {
      setTimeout(() => this.initPlaceAutocomplete(), 100);
    } else {
      setTimeout(() => this.waitForGoogleMaps(), 500);
    }
  }

  async initPlaceAutocomplete() {
    try {
      console.log('ðŸ”§ Creating PlaceAutocompleteElement');
      
      // Import the Places library to get PlaceAutocompleteElement
      const { PlaceAutocompleteElement } = await google.maps.importLibrary("places") as any;
      
      // Create the element programmatically
      this.placeAutocompleteElement = new PlaceAutocompleteElement();
      this.placeAutocompleteElement.setAttribute('placeholder', 'Enter your address...');
      
      // Append it to the container
      this.placePickerContainer.nativeElement.appendChild(this.placeAutocompleteElement);
      
      console.log('âœ… PlaceAutocompleteElement created and appended');
      console.log('ðŸ“‹ Element type:', this.placeAutocompleteElement.constructor.name);
      console.log('ðŸ“‹ Element tag:', this.placeAutocompleteElement.tagName);
      console.log('ðŸ“‹ Element:', this.placeAutocompleteElement);
      
      // Check for the 'place' property which should be set after selection
      console.log('ðŸ“‹ Has place property?', 'place' in this.placeAutocompleteElement);
      
      // NOTE: PlaceAutocompleteElement does NOT expose its internal input
      // We can only get place data via the 'gmp-placeselect' event
      // Users MUST select from the autocomplete dropdown
      
      // DEBUG: Listen for ALL possible events to see what's firing
      const eventsToTest = [
        'gmp-placeselect', 
        'place-changed',
        'placechanged',
        'change', 
        'select',
        'autocomplete-select'
      ];
      
      eventsToTest.forEach(eventName => {
        this.placeAutocompleteElement.addEventListener(eventName, (e: any) => {
          console.log(`ðŸ”” EVENT DETECTED: ${eventName}`, e);
        });
      });
      
      // Also try using the 'place' property with input event
      this.placeAutocompleteElement.addEventListener('input', (e: any) => {
        if (this.placeAutocompleteElement.place) {
          console.log('âœ… PLACE PROPERTY SET ON INPUT!', this.placeAutocompleteElement.place);
        }
      });
      
      // Listen for place selection - trying both possible event names
      this.placeAutocompleteElement.addEventListener('gmp-placeselect', async (event: any) => {
        console.log('ðŸŽ¯ gmp-placeselect EVENT FIRED!', event);
        
        const place = event.place;
        console.log('ðŸ“¦ Step 1: Place object extracted from event:', place);
        
        if (!place) {
          console.error('âŒ No place in event');
          return;
        }

        console.log('ï¿½ Step 2: Fetching place fields...');
        // Fetch the fields we need
        await place.fetchFields({
          fields: ['displayName', 'formattedAddress', 'location']
        });
        console.log('âœ… Step 3: Place fields fetched successfully');
        
        console.log('ðŸ’¾ Step 4: Updating component state...');
        this.selectedPlace = place;
        console.log('  - this.selectedPlace =', this.selectedPlace);
        
        this.address = place.formattedAddress || place.displayName || '';
        console.log('  - this.address =', this.address);
        
        console.log('âœ… Place selected:', this.address);
        console.log('ðŸ“ Location:', place.location);
        
        // Automatically trigger search after selection
        if (this.address && place.location) {
          console.log('ðŸ”¢ Step 5: Extracting coordinates...');
          // Check if lat/lng are methods or properties
          const lat = typeof place.location.lat === 'function' ? place.location.lat() : place.location.lat;
          const lng = typeof place.location.lng === 'function' ? place.location.lng() : place.location.lng;
          console.log('  - latitude:', lat);
          console.log('  - longitude:', lng);
          console.log('ðŸš€ AUTO-TRIGGERING SEARCH with coordinates:', lat, lng);
          
          console.log('â³ Step 6: Setting loading state...');
          this.loading = true;
          console.log('  - this.loading =', this.loading);
          
          console.log('ðŸ“¦ Step 7: Creating search request...');
          const searchRequest: SearchRequest = {
            address: this.address,
            latitude: lat,
            longitude: lng,
            preferences: this.preferences
          };
          console.log('ðŸ“¤ Auto-search request:', searchRequest);
          
          console.log('ðŸš€ Step 8: Executing performSearch()...');
          this.performSearch(searchRequest);
        } else {
          console.error('âŒ Missing address or location after place select');
        }
      });

      console.log('âœ… PlaceAutocompleteElement listeners added');
    } catch (error) {
      console.error('âŒ Error initializing PlaceAutocompleteElement:', error);
    }
  }

  // Helper method to get the current input value
  // NOTE: PlaceAutocompleteElement does NOT expose input value
  // This will always return empty - keeping for compatibility
  getInputValue(): string {
    // Cannot access input from PlaceAutocompleteElement
    return '';
  }

  useCurrentLocation() {
    console.log('ðŸ” Getting current location...');
    this.loading = true;
    this.locationService.getCurrentPosition().subscribe({
      next: (position) => {
        console.log('âœ… Location received:', position.coords.latitude, position.coords.longitude);
        const searchRequest: SearchRequest = {
          address: 'Current Location',
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          preferences: this.preferences
        };
        console.log('ðŸ“¤ Sending search request:', searchRequest);
        this.performSearch(searchRequest);
      },
      error: (error) => {
        console.error('âŒ Error getting location:', error);
        alert('Unable to get your location. Please enter an address manually.');
        this.loading = false;
      }
    });
  }

  searchByAddress() {
    console.log('ðŸ” Manual search triggered');
    
    // PlaceAutocompleteElement does NOT expose typed input
    // User must select a place from the autocomplete dropdown
    // which will populate this.selectedPlace and this.address
    
    if (!this.address || !this.address.trim()) {
      console.error('âŒ No address selected');
      alert('Please select an address from the autocomplete suggestions');
      return;
    }

    this.loading = true;

    // If user selected from autocomplete, use those coordinates
    if (this.selectedPlace && this.selectedPlace.location) {
      // Check if lat/lng are methods or properties
      const lat = typeof this.selectedPlace.location.lat === 'function' ? this.selectedPlace.location.lat() : this.selectedPlace.location.lat;
      const lng = typeof this.selectedPlace.location.lng === 'function' ? this.selectedPlace.location.lng() : this.selectedPlace.location.lng;
      console.log('âœ… Using autocomplete coordinates:', lat, lng);
      
      const searchRequest: SearchRequest = {
        address: this.address,
        latitude: lat,
        longitude: lng,
        preferences: this.preferences
      };
      console.log('ðŸ“¤ Sending search request:', searchRequest);
      this.performSearch(searchRequest);
      return;
    }

    // This shouldn't happen since address is only set via autocomplete selection
    console.log('ðŸ” Geocoding address:', this.address);
    this.apiService.geocodeAddress(this.address).subscribe({
      next: (coords) => {
        console.log('âœ… Geocoded to:', coords);
        const searchRequest: SearchRequest = {
          address: this.address,
          latitude: coords.latitude,
          longitude: coords.longitude,
          preferences: this.preferences
        };
        console.log('ðŸ“¤ Sending search request:', searchRequest);
        this.performSearch(searchRequest);
      },
      error: (error) => {
        console.error('âŒ Geocoding error:', error);
        alert('Unable to find location. Please check your address.');
        this.loading = false;
      }
    });
  }

  private performSearch(searchRequest: SearchRequest) {
    this.loading = false;
    this.onSearch.emit(searchRequest);
  }

  toggleDietaryDropdown() {
    this.showDietaryDropdown = !this.showDietaryDropdown;
  }

  toggleDietaryRestriction(restriction: string) {
    const index = this.preferences.dietaryRestrictions.indexOf(restriction);
    if (index > -1) {
      this.preferences.dietaryRestrictions.splice(index, 1);
    } else {
      this.preferences.dietaryRestrictions.push(restriction);
    }
  }

  isDietaryRestrictionSelected(restriction: string): boolean {
    return this.preferences.dietaryRestrictions.includes(restriction);
  }
}
